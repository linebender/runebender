use std::path::PathBuf;
#[cfg(feature = "notify")]
use std::time::Duration;

#[cfg(feature = "notify")]
use druid::ExtEventSink;
use druid::{widget::prelude::*, Selector};

use crate::{LoadableTheme, ThemeLoadError};

pub const RELOAD_THEME: Selector<()> = Selector::new("runebender.theme-loader-reload");

#[cfg(feature = "notify")]
const RELOAD_DURATION: Duration = Duration::from_millis(500);

/// A widget that loads a theme from file and applies it to the [`Env`].
///
/// This can optionally reload the theme when it changes, if the `notify`
/// feature is enabled.
pub struct ThemeLoader<T, W> {
    theme_path: PathBuf,
    theme: T,
    current_env: Option<Env>,
    inner: W,
}

impl<T: LoadableTheme, W> ThemeLoader<T, W> {
    /// Create a new `ThemeLoader`.
    ///
    /// The `path` argument should be a path to the theme file. The `them`
    /// argument is a theme generated by the [`loadable_theme!`] macro.
    ///
    /// [`loadable_theme!`] crate::loadable_theme
    pub fn new(path: impl Into<PathBuf>, theme: T, inner: W) -> Self {
        ThemeLoader {
            theme_path: path.into(),
            theme,
            inner,
            current_env: None,
        }
    }

    fn add_env_to_theme(&mut self, env: &Env) -> Result<Env, ThemeLoadError> {
        let file_contents = std::fs::read_to_string(&self.theme_path)?;
        let contents = crate::parse::iter_items(&file_contents).collect::<Result<_, _>>()?;
        let r = self.theme.load(&contents, env);
        if r.is_ok() {
            log::info!("loaded {} items to theme", contents.len());
        }
        r
    }

    fn reload_theme_and_log_errors(&mut self, env: &Env) {
        match self.add_env_to_theme(env) {
            Ok(new_env) => self.current_env = Some(new_env),
            Err(e) => log::error!("error loading theme file: {}", e),
        }
    }
}

impl<T, S, W> Widget<T> for ThemeLoader<S, W>
where
    T: Data,
    S: LoadableTheme,
    W: Widget<T>,
{
    fn event(&mut self, ctx: &mut EventCtx, event: &Event, data: &mut T, env: &Env) {
        match event {
            Event::Command(cmd) if cmd.is(RELOAD_THEME) => {
                self.reload_theme_and_log_errors(env);
                ctx.request_layout();
                ctx.set_handled();
            }
            _ => (),
        }
        let child_env = self.current_env.as_ref().unwrap_or(env);
        self.inner.event(ctx, event, data, child_env);
    }

    fn lifecycle(&mut self, ctx: &mut LifeCycleCtx, event: &LifeCycle, data: &T, env: &Env) {
        if matches!(event, LifeCycle::WidgetAdded) {
            // spin up our watcher thread
            #[cfg(feature = "notify")]
            {
                let event_snk = ctx.get_external_handle();
                start_watcher(event_snk, self.theme_path.clone(), ctx.widget_id());
            }
            self.reload_theme_and_log_errors(env);
        }
        let child_env = self.current_env.as_ref().unwrap_or(env);
        self.inner.lifecycle(ctx, event, data, child_env)
    }

    fn update(&mut self, ctx: &mut UpdateCtx, old_data: &T, data: &T, env: &Env) {
        if ctx.env_changed() {
            self.reload_theme_and_log_errors(env);
        }

        let child_env = self.current_env.as_ref().unwrap_or(env);
        self.inner.update(ctx, old_data, data, child_env);
    }

    fn layout(&mut self, ctx: &mut LayoutCtx, bc: &BoxConstraints, data: &T, env: &Env) -> Size {
        let child_env = self.current_env.as_ref().unwrap_or(env);
        self.inner.layout(ctx, bc, data, child_env)
    }

    fn paint(&mut self, ctx: &mut PaintCtx, data: &T, env: &Env) {
        let child_env = self.current_env.as_ref().unwrap_or(env);
        self.inner.paint(ctx, data, child_env);
    }

    fn id(&self) -> Option<WidgetId> {
        self.inner.id()
    }
}

#[cfg(feature = "notify")]
fn start_watcher(sink: ExtEventSink, path: PathBuf, target: WidgetId) {
    use notify::{DebouncedEvent, RecursiveMode, Watcher};
    use std::sync::mpsc;
    std::thread::spawn(move || {
        let (tx, rx) = mpsc::channel();
        let mut watcher = notify::watcher(tx, RELOAD_DURATION).unwrap();
        if let Err(e) = watcher.watch(&path, RecursiveMode::NonRecursive) {
            log::error!(
                "theme watcher failed to watch path '{}': '{}'",
                path.to_string_lossy(),
                e
            );
            return;
        }

        loop {
            match rx.recv() {
                Ok(DebouncedEvent::Write(_)) => {
                    if sink.submit_command(RELOAD_THEME, (), target).is_err() {
                        break;
                    }
                }
                Ok(_) => (),
                Err(e) => {
                    log::error!("watch error: {:?}", e);
                    break;
                }
            }
        }
    });
}
